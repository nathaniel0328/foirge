print("[The Forge] Script Starting (Zone Update + V2 Top + AFK)...")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local MarketplaceService = game:GetService("MarketplaceService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local VirtualUser = game:GetService("VirtualUser") -- Added for Anti-AFK

local LocalPlayer = Players.LocalPlayer

-- Check Game ID
if game.GameId ~= 7671049560 then
    warn("[The Forge] ⚠️ Warning: Game ID mismatch! Script might not work correctly.")
end

_G.TheForgeLoaded = true 

-- Services Setup
local KnitServices = ReplicatedStorage:WaitForChild("Shared", 5):WaitForChild("Packages", 5):WaitForChild("Knit", 5):WaitForChild("Services", 5)

-- Helper to safely get remotes
local function GetServiceRemote(serviceName, remoteType, remoteName)
    local success, result = pcall(function()
        local service = KnitServices:WaitForChild(serviceName, 2)
        if service then
            local rf = service:WaitForChild("RF", 1)
            if rf then
                return rf:WaitForChild(remoteName, 1)
            end
        end
        return nil
    end)
    return result
end

-- --- SPECIFIC SELL REMOTE SETUP ---
local SellRemote = nil
pcall(function()
    SellRemote = ReplicatedStorage:WaitForChild("Shared", 10)
        :WaitForChild("Packages", 10)
        :WaitForChild("Knit", 10)
        :WaitForChild("Services", 10)
        :WaitForChild("DialogueService", 10)
        :WaitForChild("RF", 10)
        :WaitForChild("RunCommand", 10)
end)
-- ---------------------------------

local Remotes = {
    RedeemCode = GetServiceRemote("CodeService", "RF", "RedeemCode"),
    ToolActivated = GetServiceRemote("ToolService", "RF", "ToolActivated"),
    StartBlock = GetServiceRemote("ToolService", "RF", "StartBlock"),
    StopBlock = GetServiceRemote("ToolService", "RF", "StopBlock"),
    Run = GetServiceRemote("CharacterService", "RF", "Run"),
    ChangeSequence = GetServiceRemote("ForgeService", "RF", "ChangeSequence"),
    StartForge = GetServiceRemote("ForgeService", "RF", "StartForge"),
    Forge = GetServiceRemote("ProximityService", "RF", "Forge"),
    Reset = GetServiceRemote("CharacterService", "RF", "Reset") 
}

-- ═══════════════════════════════════════════════════════════════════════════
-- ITEMS BY RARITY
-- ═══════════════════════════════════════════════════════════════════════════
local ItemsByRarity = {
    Common = { "Stone", "Sand Stone", "Copper", "Iron", "Cardboardite" },
    Uncommon = { "Cobalt", "Titanium", "Lapis Lazuli", "Tin", "Silver", "Gold", "Bananite" },
    Rare = { "Volcanic Rock", "Quartz", "Amethyst", "Boneite", "Dark Boneite", "Topaz", "Diamond", "Sapphire", "Mushroomite", "Platinum" },
    Epic = { "Aite", "Slimite", "Poopite", "Cuprite", "Obsidian", "Emerald", "Ruby", "Rivalite" },
    Legendary = { "Uranium", "Mythril", "Eye Ore", "Fireite", "Magmaite", "Lightite" },
    Mythical = { "Demonite", "Darkryte" },
    Rune = { "Frost Speck", "Venom Crumb", "Blast Chip", "Miner Shard", "Flame Spark", "Drain Edge", "Briar Notch", "Ward Patch", "Rot Stich", "Chill Dust", "Rage Mark" }
}

local AllSellableItems = {}
for _, list in pairs(ItemsByRarity) do
    for _, item in ipairs(list) do table.insert(AllSellableItems, item) end
end
table.sort(AllSellableItems)

-- Configuration
local Config = {
    AutoRun = false,
    AutoMine = false,
    SpinMining = false,
    MineTargets = {},
    PriorityOre = "None",
    FightCloseMobs = false,
    AutoAttack = false,
    AutoParry = false,
    AttackTargets = {},
    ForgeItemType = "Weapon",
    InfiniteFly = false,
    ClickTeleport = false,
    AutoSell = false,
    SellWhitelist = {}, 
    AvoidOccupied = true, 
    AvoidGoblinCave = false,
    SelectedOre = "Iron",
    ForgeQty = 1,
    SelectedSellItems = {},
    SelectedZones = {},
    AutoFarmV2 = false
}

local ScriptAPI = {}
local ActiveTargets = { Mining = nil, Combat = nil }
local IsTweening = false
local TWEEN_SPEED = 70 
local CurrentTweenTrack = nil 

-- New Global for V2 Delay Logic
local IsV2FarmingReady = false

--------------------------------------------------------------------------------
-- CORE FUNCTIONS
--------------------------------------------------------------------------------

local function TweenCharacterTo(targetCFrame)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local finalCFrame = targetCFrame - Vector3.new(0, 8, 0)

    if CurrentTweenTrack then task.cancel(CurrentTweenTrack) end
    
    CurrentTweenTrack = task.spawn(function()
        IsTweening = true
        
        local sinkPos = root.Position - Vector3.new(0, 8, 0)
        local time1 = (sinkPos - root.Position).Magnitude / TWEEN_SPEED
        local tween1 = TweenService:Create(root, TweenInfo.new(time1), {CFrame = CFrame.new(sinkPos)})
        tween1:Play(); tween1.Completed:Wait()

        local time2 = (finalCFrame.Position - root.Position).Magnitude / TWEEN_SPEED
        local tween2 = TweenService:Create(root, TweenInfo.new(time2), {CFrame = finalCFrame})
        tween2:Play(); tween2.Completed:Wait()
        
        IsTweening = false
    end)
end

local function InitializeNoclip()
    LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
    RunService.Stepped:Connect(function()
        if Config.AutoMine or Config.AutoAttack or Config.FightCloseMobs or IsTweening or Config.AutoFarmV2 then
            local char = LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then part.CanCollide = false end
                end
            end
        end
    end)
end

local function InitializeAutoRun()
    task.spawn(function()
        while true do
            task.wait(0.5)
            if Config.AutoRun and Remotes.Run then
                local char = LocalPlayer.Character
                if char and char:FindFirstChild("Humanoid") then Remotes.Run:InvokeServer() end
            end
        end
    end)
end

local function FindCloseMob(range)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local living = Workspace:FindFirstChild("Living")
    local closest, dist = nil, range
    if living then
        for _, mob in ipairs(living:GetChildren()) do
            if mob:IsA("Model") and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") 
            and not mob:FindFirstChild("RaceFolder") 
            and not Players:GetPlayerFromCharacter(mob) then
                 local d = (mob.HumanoidRootPart.Position - root.Position).Magnitude
                 if d < dist then dist = d; closest = mob end
            end
        end
    end
    return closest
end

-- ═══════════════════════════════════════════════════════════════════════════
-- AUTO MINE
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeAutoMine()
    ScriptAPI.GetRockTypes = function()
        local rockTypes = {}
        local seen = {}
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if rocksFolder then
            for _, category in ipairs(rocksFolder:GetChildren()) do
                for _, child in ipairs(category:GetChildren()) do
                    if child.Name == "SpawnLocation" then
                        for _, model in ipairs(child:GetChildren()) do
                            if model:IsA("Model") and model:FindFirstChild("Hitbox") and not seen[model.Name] then
                                seen[model.Name] = true; table.insert(rockTypes, model.Name)
                            end
                        end
                    elseif child:IsA("Model") and child:FindFirstChild("Hitbox") and not seen[child.Name] then
                        seen[child.Name] = true; table.insert(rockTypes, child.Name)
                    end
                end
            end
        end
        table.sort(rockTypes)
        return rockTypes
    end
    
    ScriptAPI.GetZoneNames = function()
        local zones = {}
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if rocksFolder then
            for _, folder in ipairs(rocksFolder:GetChildren()) do
                table.insert(zones, folder.Name)
            end
        end
        table.sort(zones)
        return zones
    end

    local function FindNearestRock(maxDist)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end
        
        local closestRock = nil
        local bestDist = maxDist or 9999
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if not rocksFolder then return nil end
        
        local foldersToScan = {}
        
        if Config.SelectedZones and #Config.SelectedZones > 0 then
            for _, zoneName in ipairs(Config.SelectedZones) do
                local z = rocksFolder:FindFirstChild(zoneName)
                if z then table.insert(foldersToScan, z) end
            end
        else
            table.insert(foldersToScan, rocksFolder)
        end
        
        local goblinCaveFolder = rocksFolder:FindFirstChild("Island2GoblinCave")

        for _, scanRoot in ipairs(foldersToScan) do
            for _, descendant in ipairs(scanRoot:GetDescendants()) do
                if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                    local rockName = descendant.Parent.Name
                    local dist = (descendant.Position - root.Position).Magnitude
                    local isValid = true
                    
                    local currentHP, maxHP = 0, 0
                    local infoFrame = descendant.Parent:FindFirstChild("infoFrame")
                    local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                    
                    if hpText then
                        local c, m = hpText:match("(%d+)%s*/%s*(%d+)")
                        if c then currentHP, maxHP = tonumber(c), tonumber(m) else currentHP = tonumber(hpText:match("^(%d+)")) or 0 end
                        if currentHP <= 0 then isValid = false end
                    end

                    if isValid and Config.AvoidOccupied and maxHP > 0 and currentHP < maxHP then isValid = false end
                    
                    if isValid and Config.AvoidGoblinCave and (#Config.SelectedZones == 0) and goblinCaveFolder and descendant:IsDescendantOf(goblinCaveFolder) then 
                        isValid = false 
                    end

                    if isValid then
                        if Config.PriorityOre ~= "None" and rockName == Config.PriorityOre then
                            if dist < bestDist then return descendant end 
                        elseif Config.MineTargets[rockName] then
                            if dist < bestDist then closestRock = descendant; bestDist = dist end
                        end
                    end
                end
            end
        end
        return closestRock
    end

    task.spawn(function()
        while true do
            task.wait(0.1)
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local humanoid = char and char:FindFirstChild("Humanoid")
            
            if Config.AutoMine and Remotes.ToolActivated and root and humanoid then
                if Config.FightCloseMobs then
                    local closeMob = FindCloseMob(20)
                    if closeMob then ActiveTargets.Combat = closeMob else if not Config.AutoAttack then ActiveTargets.Combat = nil end end
                end

                if not ActiveTargets.Combat then
                    local pickaxe = char:FindFirstChild("Pickaxe")
                    if not pickaxe then
                        local bp = LocalPlayer.Backpack:FindFirstChild("Pickaxe")
                        if bp then humanoid:EquipTool(bp); pickaxe = bp end
                    end

                    local targetValid = false
                    if ActiveTargets.Mining and ActiveTargets.Mining.Parent then
                         local rName = ActiveTargets.Mining.Parent.Name
                         if rName == Config.PriorityOre or Config.MineTargets[rName] then
                             local info = ActiveTargets.Mining.Parent:FindFirstChild("infoFrame")
                             if info then
                                 local txt = info.Frame.rockHP.Text
                                 if txt and not txt:match("^0") then targetValid = true end
                             else targetValid = true end
                         end
                    end
                    
                    if not targetValid then ActiveTargets.Mining = nil end
                    if not ActiveTargets.Mining then ActiveTargets.Mining = FindNearestRock(2000) end

                    if pickaxe and ActiveTargets.Mining and ActiveTargets.Mining.Parent then
                         local dist = (root.Position - ActiveTargets.Mining.Position).Magnitude
                         if dist <= 25 then Remotes.ToolActivated:InvokeServer("Pickaxe") end
                    end
                end
            else
                ActiveTargets.Mining = nil
            end
        end
    end)

    RunService.Heartbeat:Connect(function(dt)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        
        if Config.AutoMine and ActiveTargets.Mining and not ActiveTargets.Combat and ActiveTargets.Mining.Parent and root then
            root.Anchored = false
            root.AssemblyLinearVelocity = Vector3.zero
            root.AssemblyAngularVelocity = Vector3.zero
            
            local targetPos = ActiveTargets.Mining.Position
            local idealPos = targetPos - Vector3.new(0, 5, 0)
            local currentPos = root.Position
            
            local dist = (idealPos - currentPos).Magnitude
            local moveDir = (idealPos - currentPos).Unit
            
            local moveDist = math.min(dist, TWEEN_SPEED * dt)
            local nextCFramePosition = currentPos + (moveDir * moveDist)

            local rotation
            if Config.SpinMining then
                rotation = CFrame.Angles(0, tick() * 15, 0) 
            else
                rotation = CFrame.lookAt(currentPos, targetPos).Rotation
            end
            root.CFrame = CFrame.new(nextCFramePosition) * rotation
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- AUTO FARM V2 (DELAYED START + STICKY LOCK + TOP POSITION)
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeAutoFarmV2()
    local RESET_INTERVAL = 3 
    local CurrentV2Target = nil
    
    local function FindAnyTargetV2()
        local living = Workspace:FindFirstChild("Living")
        if not living then return nil end
        
        local closest, bestDist = nil, 9999
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end

        for _, mob in ipairs(living:GetChildren()) do
            if mob:IsA("Model") and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") 
            and not mob:FindFirstChild("RaceFolder") 
            and not Players:GetPlayerFromCharacter(mob) then
                local cleanName = mob.Name:gsub("%d+$", "")
                local shouldAttack = true
                
                local hasTargets = false
                for k, v in pairs(Config.AttackTargets) do if v then hasTargets = true break end end
                
                if hasTargets and not Config.AttackTargets[cleanName] then
                    shouldAttack = false
                end

                if shouldAttack then
                    local d = (mob.HumanoidRootPart.Position - root.Position).Magnitude
                    if d < bestDist then bestDist = d; closest = mob end
                end
            end
        end
        return closest
    end

    -- 1. Reset Loop (Waits for IsV2FarmingReady)
    task.spawn(function()
        while true do
            if Config.AutoFarmV2 and IsV2FarmingReady then
                pcall(function()
                    if Remotes.Reset then
                        print("[Auto Farm V2] Loop Reset")
                        Remotes.Reset:InvokeServer()
                    end
                end)
                task.wait(RESET_INTERVAL)
            else
                task.wait(0.5)
            end
        end
    end)

    -- 2. Lock & Kill Loop (Heartbeat) - STICKY TARGET LOGIC
    RunService.Heartbeat:Connect(function()
        if not Config.AutoFarmV2 or not IsV2FarmingReady then 
            CurrentV2Target = nil -- Reset target when disabled
            return 
        end

        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")

        if root and humanoid then 
            
            -- A. Validate Current Target (Stickiness)
            if CurrentV2Target then
                if not CurrentV2Target.Parent 
                or not CurrentV2Target:FindFirstChild("Humanoid") 
                or CurrentV2Target.Humanoid.Health <= 0 
                or not CurrentV2Target:FindFirstChild("HumanoidRootPart") then
                    CurrentV2Target = nil -- Target died or invalidated
                end
            end

            -- B. Find New Target if None
            if not CurrentV2Target then
                CurrentV2Target = FindAnyTargetV2()
            end
            
            local target = CurrentV2Target

            if target and target:FindFirstChild("HumanoidRootPart") then
                -- UPDATED: Teleport ABOVE the mob (9 studs)
                local targetPos = target.HumanoidRootPart.Position
                local abovePos = targetPos + Vector3.new(0, 9, 0)
                
                root.CFrame = CFrame.new(abovePos) * CFrame.lookAt(abovePos, targetPos).Rotation

                root.AssemblyLinearVelocity = Vector3.zero
                root.AssemblyAngularVelocity = Vector3.zero

                local weapon = char:FindFirstChildWhichIsA("Tool")
                if not weapon then
                    local bpWeapon = LocalPlayer.Backpack:FindFirstChildWhichIsA("Tool") 
                    if bpWeapon then humanoid:EquipTool(bpWeapon); weapon = bpWeapon end
                end
                
                if Remotes.ToolActivated then
                    Remotes.ToolActivated:InvokeServer("Weapon")
                end
            end
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- STANDARD COMBAT
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeCombat()
    local isBlocking = false
    
    ScriptAPI.GetMobTypes = function()
        local mobs = {}
        local seen = {}
        local living = Workspace:FindFirstChild("Living")
        if living then
            for _, model in ipairs(living:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("Humanoid") and not model:FindFirstChild("RaceFolder") then
                    if not Players:GetPlayerFromCharacter(model) then
                        local name = model.Name:gsub("%d+$", "")
                        if not seen[name] then seen[name] = true; table.insert(mobs, name) end
                    end
                end
            end
        end
        table.sort(mobs)
        return mobs
    end

    local function FindTarget(maxDist)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end
        local bestTarget, bestDist = nil, maxDist or 2000
        local living = Workspace:FindFirstChild("Living")
        if living then
            for _, mob in ipairs(living:GetChildren()) do
                if mob:IsA("Model") and mob:FindFirstChild("Humanoid") then
                    if not Players:GetPlayerFromCharacter(mob) then
                        local cleanName = mob.Name:gsub("%d+$", "")
                        if Config.AttackTargets and Config.AttackTargets[cleanName] and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") then
                            local dist = (mob.HumanoidRootPart.Position - root.Position).Magnitude
                            if dist < bestDist then bestTarget = mob; bestDist = dist end
                        end
                    end
                end
            end
        end
        return bestTarget
    end

    task.spawn(function()
        while true do
            task.wait(0.05) 
            -- Skip standard combat if V2 is on
            if Config.AutoFarmV2 then 
                task.wait(0.5)
                continue 
            end

            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local shouldRunCombat = (Config.AutoAttack or (Config.FightCloseMobs and ActiveTargets.Combat))
            
            if shouldRunCombat and Remotes.ToolActivated and root then
                local weapon = char:FindFirstChildWhichIsA("Tool")
                local targetValid = false
                if ActiveTargets.Combat and ActiveTargets.Combat.Parent and ActiveTargets.Combat:FindFirstChild("Humanoid") and ActiveTargets.Combat.Humanoid.Health > 0 then
                    targetValid = true
                end

                if not targetValid then
                    ActiveTargets.Combat = nil
                    if isBlocking then Remotes.StopBlock:InvokeServer(); isBlocking = false end
                end

                if not ActiveTargets.Combat and Config.AutoAttack then ActiveTargets.Combat = FindTarget(2000) end
                
                local target = ActiveTargets.Combat
                if weapon and target and target.Parent then
                    local targetRoot = target:FindFirstChild("HumanoidRootPart")
                    local dist = targetRoot and (root.Position - targetRoot.Position).Magnitude or 100
                    
                    if dist <= 15 then
                        local shouldBlock = false
                        if Config.AutoParry then
                            local status = target:FindFirstChild("Status")
                            if status and status:FindFirstChild("Attacking") and status.Attacking.Value == true then shouldBlock = true end
                        end
                        if shouldBlock then
                            if not isBlocking then Remotes.StartBlock:InvokeServer(); isBlocking = true end
                        else
                            if isBlocking then Remotes.StopBlock:InvokeServer(); isBlocking = false end
                            Remotes.ToolActivated:InvokeServer("Weapon")
                        end
                    else
                        if isBlocking then Remotes.StopBlock:InvokeServer(); isBlocking = false end
                    end
                end
            else
                if not Config.FightCloseMobs and not Config.AutoAttack then ActiveTargets.Combat = nil end
                if isBlocking then pcall(function() Remotes.StopBlock:InvokeServer() end); isBlocking = false end
            end
        end
    end)

    RunService.Heartbeat:Connect(function(dt)
        -- Disable standard combat movement if V2 is on
        if Config.AutoFarmV2 then return end

        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local shouldMove = (Config.AutoAttack or Config.FightCloseMobs)
        
        if shouldMove and ActiveTargets.Combat and ActiveTargets.Combat.Parent and root then
            local targetRoot = ActiveTargets.Combat:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                local targetPos = targetRoot.Position
                local idealPos = targetPos + Vector3.new(0, 9, 0) -- Hover 8 studs ABOVE
                
                local currentPos = root.Position
                local distToTarget = (idealPos - currentPos).Magnitude
                
                root.Anchored = false
                root.AssemblyLinearVelocity = Vector3.zero
                root.AssemblyAngularVelocity = Vector3.zero
                
                local moveDir = (idealPos - currentPos).Unit
                local moveDist = math.min(distToTarget, TWEEN_SPEED * dt)
                root.CFrame = CFrame.new(currentPos + moveDir * moveDist) * CFrame.lookAt(idealPos, targetPos).Rotation
            end
        end
    end)
end

local function InitializeForgeAndSell()
    local function GenuineForge(ores, itemType, notifyFunc)
        local forgeModel = Workspace:WaitForChild("Proximity", 5) and Workspace.Proximity:WaitForChild("Forge", 5)
        if not Remotes.StartForge or not forgeModel then return end
        if not itemType then itemType = "Weapon" end
        
        if notifyFunc then notifyFunc("Forge", "Starting Forge...") end
        Remotes.Forge:InvokeServer(forgeModel); task.wait(0.2)
        Remotes.StartForge:InvokeServer(forgeModel)
        
        TweenCharacterTo(forgeModel.Smelter.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer(unpack({"Melt", {FastForge = false, ItemType = itemType, Ores = ores}}))
        task.wait(5.5)

        Remotes.ChangeSequence:InvokeServer("Pour", { ClientTime = Workspace:GetServerTimeNow() })
        task.wait(4.5)

        TweenCharacterTo(forgeModel.Anvil.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer("Hammer", { ClientTime = Workspace:GetServerTimeNow() })
        for i = 1, 6 do Remotes.ToolActivated:InvokeServer("Hammer"); task.wait(0.6) end
        
        TweenCharacterTo(forgeModel.Trough.CFrame); task.wait(1)
        task.spawn(function() Remotes.ChangeSequence:InvokeServer("Water", { ClientTime = Workspace:GetServerTimeNow() }) end)
        task.wait(2)

        Remotes.ChangeSequence:InvokeServer("Showcase", {})
        if notifyFunc then notifyFunc("Forge", "Completed!") end
    end

    local function GetInventoryData()
        local inventory = {}
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        local stash = playerGui and playerGui:FindFirstChild("Menu") and playerGui.Menu:FindFirstChild("Frame") and playerGui.Menu.Frame:FindFirstChild("Frame") and playerGui.Menu.Frame.Frame:FindFirstChild("Menus") and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Stash") and playerGui.Menu.Frame.Frame.Menus.Stash:FindFirstChild("Background")
        if stash then
            for _, itemFrame in ipairs(stash:GetChildren()) do
                if itemFrame:IsA("Frame") and itemFrame:FindFirstChild("Main") then
                    local name = itemFrame.Main.ItemName.Text
                    local qty = tonumber(itemFrame.Main.Quantity.Text:match("%d+")) or 0
                    if name and qty > 0 then inventory[name:match("^%s*(.-)%s*$")] = qty end
                end
            end
        end
        return inventory
    end

    local function GetPlayerMoney()
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if not playerGui then return "N/A" end
        local possibleLocations = {
            playerGui:FindFirstChild("Menu") and playerGui.Menu:FindFirstChild("Frame") and playerGui.Menu.Frame:FindFirstChild("Frame"),
            playerGui:FindFirstChild("HUD"), playerGui:FindFirstChild("Main")
        }
        for _, gui in ipairs(possibleLocations) do
            if gui then
                for _, descendant in ipairs(gui:GetDescendants()) do
                    if (descendant:IsA("TextLabel") or descendant:IsA("TextBox")) then
                        local text = descendant.Text
                        if text:find("%$") or text:lower():find("money") or text:lower():find("cash") or text:lower():find("gold") then return text end
                    end
                end
            end
        end
        return "Unknown"
    end

    local function TalkToSeller()
        local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return false end
        local oldPos = root.CFrame
        root.CFrame = CFrame.new(SELLER_POSITION)
        task.wait(0.5)
        local prompt = Workspace.Proximity["Greedy Cey"].ProximityPrompt
        if prompt then
            fireproximityprompt(prompt); task.wait(0.5)
            pcall(function()
                VirtualInputManager:SendMouseButtonEvent(1200, 498, 0, true, game, 1); task.wait(0.01)
                VirtualInputManager:SendMouseButtonEvent(1200, 498, 0, false, game, 1)
            end)
            task.wait(0.3); root.CFrame = oldPos; return true
        end
        return false
    end

    local function SellSelectedItems(notifyFunc)
        if not SellRemote then return end
        local inventory = GetInventoryData()
        local itemsToSell = {}
        for _, itemName in ipairs(Config.SelectedSellItems) do
            local qty = inventory[itemName] or 0
            if qty > 0 then itemsToSell[itemName] = qty end
        end
        if next(itemsToSell) ~= nil then
            SellRemote:InvokeServer("SellConfirm", {Basket = itemsToSell})
            if notifyFunc then notifyFunc("Sold", "Sold items successfully!") end
        end
    end

    ScriptAPI.GenuineForge = GenuineForge
    ScriptAPI.GetAvailableOres = GetInventoryData
    ScriptAPI.SellSelectedItems = SellSelectedItems
    ScriptAPI.TalkToSeller = TalkToSeller
    ScriptAPI.GetPlayerMoney = GetPlayerMoney

    task.spawn(function()
        while true do
            task.wait(2)
            if Config.AutoSell then SellSelectedItems(nil) end
        end
    end)
end

local function InitializeMovement()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if Config.ClickTeleport and input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            local mouse = LocalPlayer:GetMouse()
            if mouse.Hit then TweenCharacterTo(CFrame.new(mouse.Hit.Position)) end
        end
    end)

    local bg, bv, flying = nil, nil, false
    local function stopFly()
        flying = false
        if bg then bg:Destroy(); bg = nil end
        if bv then bv:Destroy(); bv = nil end
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then LocalPlayer.Character.Humanoid.PlatformStand = false end
    end
    local function startFly()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        flying = true
        char.Humanoid.PlatformStand = true
        bg = Instance.new("BodyGyro", root); bg.P = 90000; bg.maxTorque = Vector3.new(9e9, 9e9, 9e9); bg.cframe = root.CFrame
        bv = Instance.new("BodyVelocity", root); bv.velocity = Vector3.zero; bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            while flying do
                local cam = Workspace.CurrentCamera
                local direction = Vector3.zero
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then direction = direction + cam.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then direction = direction - cam.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then direction = direction - cam.CFrame.RightVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then direction = direction + cam.CFrame.RightVector end
                if direction.Magnitude > 0 then bv.velocity = direction.Unit * 50 else bv.velocity = Vector3.zero end
                bg.cframe = cam.CFrame
                RunService.RenderStepped:Wait()
            end
            stopFly()
        end)
    end
    task.spawn(function()
        while true do
            task.wait(0.2)
            if Config.InfiniteFly then if not flying then startFly() end else if flying then stopFly() end end
        end
    end)
    LocalPlayer.CharacterAdded:Connect(function() if flying then stopFly() end end)
end

local function RedeemAllCodes()
    for _, code in ipairs({"40KLIKES", "20KLIKES", "15KLIKES", "10KLIKES", "5KLIKES", "BETARELEASE!", "POSTRELEASEQNA"}) do
        task.spawn(function() Remotes.RedeemCode:InvokeServer(code) end); task.wait(0.2)
    end
end

-- -----------------------------------------------------------------------------
-- ANTI-AFK (ALWAYS ENABLED)
-- -----------------------------------------------------------------------------
pcall(function()
    if LocalPlayer then
        LocalPlayer.Idled:Connect(function()
            if VirtualUser then
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
                print("✅ Anti-AFK: Prevented idle kick")
            end
        end)
    end
end)

InitializeNoclip()
InitializeAutoMine()
InitializeAutoRun()
InitializeCombat()
InitializeAutoFarmV2() -- INITIALIZE V2
InitializeForgeAndSell()
InitializeMovement()

--------------------------------------------------------------------------------
-- UI SETUP (RAYFIELD - BLUE THEME)
--------------------------------------------------------------------------------
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({Name = "The Forge Script", LoadingTitle = "", LoadingSubtitle = "", ConfigurationSaving = {Enabled = true, FolderName = "TheForgeScript", FileName = "Config"}, KeySystem = false, Theme = "Ocean"})

local FarmingTab = Window:CreateTab("Farming", 4483362458)
local CombatTab = Window:CreateTab("Combat", 4483362458)
local SellingTab = Window:CreateTab("Selling", 4483362458)
local ForgeTab = Window:CreateTab("Forge", 4483362458)
local TeleportTab = Window:CreateTab("Teleport", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

FarmingTab:CreateSection("Auto Mine")
FarmingTab:CreateToggle({Name = "Enabled", CurrentValue = false, Flag = "AutoMine", Callback = function(v) Config.AutoMine = v end})
FarmingTab:CreateToggle({Name = "Spin While Mining", CurrentValue = false, Flag = "SpinMining", Callback = function(v) Config.SpinMining = v end})
FarmingTab:CreateToggle({Name = "Avoid Occupied Ores", CurrentValue = true, Flag = "AvoidOccupied", Callback = function(v) Config.AvoidOccupied = v end})
FarmingTab:CreateToggle({Name = "Avoid Goblin Cave Ores (Legacy)", CurrentValue = false, Flag = "AvoidGoblinCave", Callback = function(v) Config.AvoidGoblinCave = v end})
FarmingTab:CreateToggle({Name = "Fight Close Mobs", CurrentValue = false, Flag = "FightCloseMobs", Callback = function(v) Config.FightCloseMobs = v end})

FarmingTab:CreateSection("Zones & Targets")
local ZoneDropdown = FarmingTab:CreateDropdown({
    Name = "Select Mining Zones (Empty = All)",
    Options = {"Loading..."},
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "MiningZones",
    Callback = function(options)
        Config.SelectedZones = options
        if #options > 0 then
        end
    end
})

task.spawn(function()
    while not ScriptAPI.GetZoneNames do task.wait(0.5) end
    local zones = ScriptAPI.GetZoneNames()
    if #zones > 0 then
        ZoneDropdown:Refresh(zones)
    end
end)

local PriorityDropdown = FarmingTab:CreateDropdown({Name = "Priority Ore", Options = {"None"}, CurrentOption = {"None"}, Flag = "PriorityOre", Callback = function(o) Config.PriorityOre = o[1] end})

local RockToggles, SeenRocks = {}, {}
task.spawn(function()
    while true do
        if ScriptAPI.GetRockTypes then
            local newRocks, needsRefresh = ScriptAPI.GetRockTypes(), false
            for _, r in ipairs(newRocks) do
                if not SeenRocks[r] then
                    SeenRocks[r] = true; needsRefresh = true
                    FarmingTab:CreateToggle({Name = "Target: "..r, CurrentValue = false, Flag = "Rock_"..r, Callback = function(v) Config.MineTargets[r] = v end})
                end
            end
            if needsRefresh then
                local opts = {"None"}; for k in pairs(SeenRocks) do table.insert(opts, k) end; table.sort(opts)
                PriorityDropdown:Refresh(opts)
            end
        end
        task.wait(5)
    end
end)

CombatTab:CreateSection("Auto Farm V2")
CombatTab:CreateToggle({
    Name = "Auto Farm V2 (Reset + TP Lock)", 
    CurrentValue = false, 
    Flag = "AutoFarmV2", 
    Callback = function(v) 
        Config.AutoFarmV2 = v 
        IsV2FarmingReady = false -- Lock farming initially

        if v then
            -- 1. Trigger First Reset Immediately
            if Remotes.Reset then 
                pcall(function() 
                    print("[Auto Farm V2] Initial Reset triggered")
                    Remotes.Reset:InvokeServer() 
                end)
            end

            -- 2. Wait 5.3 Seconds before starting the farm loop
            task.spawn(function()
                task.wait(5.3)
                if Config.AutoFarmV2 then -- Check if user didn't disable it during wait
                    print("[Auto Farm V2] 5.3s Delay over. Starting loops.")
                    IsV2FarmingReady = true
                end
            end)
        else
            IsV2FarmingReady = false
        end
    end
})

CombatTab:CreateSection("Standard Combat")
CombatTab:CreateToggle({Name = "Auto Attack", CurrentValue = false, Flag = "AutoAttack", Callback = function(v) Config.AutoAttack = v end})
CombatTab:CreateToggle({Name = "Auto Block", CurrentValue = false, Flag = "AutoBlock", Callback = function(v) Config.AutoParry = v end})
CombatTab:CreateSection("Targets")
local SeenMobs = {}
task.spawn(function()
    while true do
        if ScriptAPI.GetMobTypes then
            for _, m in ipairs(ScriptAPI.GetMobTypes()) do
                if not SeenMobs[m] then
                    SeenMobs[m] = true
                    CombatTab:CreateToggle({Name = "Farm: "..m, CurrentValue = false, Flag = "Mob_"..m, Callback = function(v) Config.AttackTargets[m] = v end})
                end
            end
        end
        task.wait(5)
    end
end)

SellingTab:CreateSection("Auto Sell")
SellingTab:CreateToggle({Name = "Enable Auto Sell", CurrentValue = false, Flag = "AutoSell", Callback = function(v) Config.AutoSell = v end})
SellingTab:CreateButton({Name = "Talk to Buyer (Fixes Shop)", Callback = function() if ScriptAPI.TalkToSeller and ScriptAPI.TalkToSeller() then Rayfield:Notify({Title = "Success", Content = "Shop opened!", Duration = 3}) end end})
SellingTab:CreateButton({Name = "Sell Selected Now", Callback = function() if ScriptAPI.SellSelectedItems then ScriptAPI.SellSelectedItems(function(t, m) Rayfield:Notify({Title = t, Content = m, Duration = 3}) end) end end})
local MoneyLabel = SellingTab:CreateParagraph({Title = "Status", Content = "Checking..."})
task.spawn(function() while true do task.wait(2); if ScriptAPI.GetPlayerMoney then MoneyLabel:Set({Title = "Status", Content = "Cash: "..ScriptAPI.GetPlayerMoney()}) end end end)
SellingTab:CreateSection("Item Selection")
SellingTab:CreateDropdown({Name = "Select Items to Sell", Options = AllSellableItems, CurrentOption = {}, MultipleOptions = true, Flag = "Sell_AllItems", Callback = function(o) Config.SelectedSellItems = o end})

ForgeTab:CreateSection("Genuine Auto Forge")
local OreStatusLabel = ForgeTab:CreateParagraph({Title = "Status", Content = "Loading Ores..."})
ForgeTab:CreateDropdown({Name = "Select Ore to Forge", Options = {"Iron"}, CurrentOption = {"Iron"}, Flag = "SelectedForgeOre", Callback = function(o) Config.SelectedOre = o[1] end})
ForgeTab:CreateSlider({Name = "Quantity to Use", Range = {1, 100}, Increment = 1, Suffix = "Ores", CurrentValue = 1, Flag = "ForgeQty", Callback = function(v) Config.ForgeQty = v end})
ForgeTab:CreateDropdown({Name = "Item Type", Options = {"Weapon", "Armor"}, CurrentOption = {"Weapon"}, Flag = "ForgeItemType", Callback = function(o) Config.ForgeItemType = o[1] end})
task.spawn(function() while true do local av = ScriptAPI.GetAvailableOres and ScriptAPI.GetAvailableOres() or {}; OreStatusLabel:Set({Title = "Inventory", Content = "Selected: "..Config.SelectedOre.."\nOwned: "..(av[Config.SelectedOre] or 0)}); task.wait(1) end end)
ForgeTab:CreateButton({Name = "Start Genuine Forge", Callback = function() if ScriptAPI.GenuineForge then local av = ScriptAPI.GetAvailableOres(); local use = math.min(Config.ForgeQty, av[Config.SelectedOre] or 0); ScriptAPI.GenuineForge({[Config.SelectedOre]=use}, Config.ForgeItemType, function(t, m) Rayfield:Notify({Title = t, Content = m, Duration = 5}) end) end end})

TeleportTab:CreateSection("Navigation") 
TeleportTab:CreateSection("Proximity Locations")
local function RefreshLocations()
    local pf = Workspace:FindFirstChild("Proximity")
    if not pf then return end
    for _, loc in ipairs(pf:GetChildren()) do
        if loc:IsA("Model") or loc:IsA("BasePart") then
            TeleportTab:CreateButton({Name = loc.Name, Callback = function()
                local tcf = loc:IsA("Model") and (loc.PrimaryPart and loc.PrimaryPart.CFrame or loc:GetPivot()) or loc.CFrame
                if tcf then TweenCharacterTo(tcf) end
            end})
        end
    end
end
RefreshLocations()

MiscTab:CreateSection("Character")
MiscTab:CreateToggle({Name = "Auto Run", CurrentValue = false, Flag = "AutoRun", Callback = function(v) Config.AutoRun = v end})
MiscTab:CreateToggle({Name = "Infinite Fly", CurrentValue = false, Flag = "InfiniteFly", Callback = function(v) Config.InfiniteFly = v end})
MiscTab:CreateToggle({Name = "Click TP (Ctrl+Click)", CurrentValue = false, Flag = "ClickTP", Callback = function(v) Config.ClickTeleport = v end})
MiscTab:CreateButton({Name = "Redeem All Codes", Callback = function() RedeemAllCodes(); Rayfield:Notify({Title = "Codes", Content = "Redeeming...", Duration = 3}) end})

print("[The Forge] Script Loaded Successfully!")
Rayfield:LoadConfiguration()
